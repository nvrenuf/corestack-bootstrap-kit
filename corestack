#!/usr/bin/env bash
set -euo pipefail

# DO NOT:
# - change PROJECT_NAME without migration logic
# - reintroduce static container_name in docker-compose.yml
# - use raw docker exec with hardcoded container names
# - remove auto-seed logic from `up`

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="${CORESTACK_COMPOSE_FILE:-${REPO_ROOT}/deploy/compose/docker-compose.yml}"
ENV_EXAMPLE_FILE="${REPO_ROOT}/deploy/compose/.env.example"
DEFAULT_ENV_FILE="${REPO_ROOT}/deploy/compose/.env"
ENV_FILE="${CORESTACK_ENV_FILE:-${DEFAULT_ENV_FILE}}"
PROJECT_NAME="${CORESTACK_PROJECT_NAME:-corestack}"
PACKS_DIR="${REPO_ROOT}/packs"

DEFAULT_CHAT_MODEL="granite3.1-moe:3b-instruct-q4_K_M"
DEFAULT_EMBEDDING_MODEL="nomic-embed-text:v1.5"
DEFAULT_SANITY_MODEL="llama3.2:3b"

usage() {
  cat <<'USAGE'
Usage: ./corestack <command> [args]

Commands:
  up [--no-seed] [--seed-models] [compose args...]
                     Create .env if missing, build, and start stack
  up <pack-id> [compose args...]
                     Start an installed pack (docker compose -p corestack-<pack-id>)
  seed-models        Pull CHAT_MODEL + EMBEDDING_MODEL (+ default sanity model)
  doctor             Run Docker, DNS, and port diagnostics
  reset [--nuke-volumes]
                     Stop/remove project containers; keep volumes by default
  down               Stop/remove containers and networks (keep volumes/data)
  down <pack-id>     Stop an installed pack
  start              Start existing containers
  stop               Stop running containers
  restart            down then up
  status             Show container status
  status <pack-id>   Show status for an installed pack
  logs [service...]  Follow logs (tail 200), optional service filters
  logs <pack-id> [service optional]
                     Follow logs for an installed pack
  destroy            Destructive: down -v after explicit confirmation
  pack list          List installed packs
  pack install <path-or-git-url>
                     Install a pack into ./packs/<pack-id>/
  pack remove <pack-id>
                     Remove an installed pack (runs down first)
  help               Show this message
USAGE
}

log_info() { echo "INFO: $*"; }
log_warn() { echo "WARN: $*" >&2; }
log_error() { echo "ERROR: $*" >&2; }

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    log_error "$1 is required"
    exit 1
  fi
}

require_tools() {
  require_cmd docker
  if ! docker compose version >/dev/null 2>&1; then
    log_error "docker compose v2 is required"
    exit 1
  fi
}

pack_project_name() {
  local pack_id="$1"
  echo "corestack-${pack_id}"
}

pack_dir() {
  local pack_id="$1"
  echo "${PACKS_DIR}/${pack_id}"
}

is_installed_pack() {
  local pack_id="$1"
  local dir
  dir="$(pack_dir "${pack_id}")"
  [[ -d "${dir}" && -f "${dir}/pack.json" ]]
}

pack_validate_dir() {
  local dir="$1"
  require_cmd python3
  python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" validate "${dir}" >/dev/null
}

pack_ensure_env() {
  local dir="$1"
  local had_env="false"
  if [[ -f "${dir}/.env" ]]; then
    had_env="true"
  fi
  if python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" ensure-env "${dir}" >/dev/null; then
    if [[ "${had_env}" != "true" ]]; then
      log_info "Created pack env file from template: ${dir}/.env"
    fi
  else
    log_error "failed to ensure pack env file for ${dir}"
    exit 1
  fi
}

pack_compose_cmd() {
  local pack_id="$1"
  shift
  local dir compose env project
  dir="$(pack_dir "${pack_id}")"
  compose="${dir}/compose.pack.yml"
  env="${dir}/.env"
  project="$(pack_project_name "${pack_id}")"

  if [[ ! -f "${compose}" ]]; then
    log_error "pack compose file not found: ${compose}"
    exit 1
  fi
  ensure_compose_file
  docker compose \
    -f "${COMPOSE_FILE}" \
    -f "${compose}" \
    --env-file "${env}" \
    -p "${project}" \
    "$@"
}

pack_list() {
  mkdir -p "${PACKS_DIR}"
  local d id meta
  for d in "${PACKS_DIR}"/*; do
    [[ -d "${d}" ]] || continue
    id="$(basename "${d}")"
    [[ "${id}" == "_template" ]] && continue
    if python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" validate "${d}" >/dev/null 2>&1; then
      printf "%s\t%s\n" "${id}" "$(python3 -c 'import json,sys; print(json.load(open(sys.argv[1], "r", encoding="utf-8")).get("version",""))' "${d}/pack.json")"
    else
      printf "%s\t%s\n" "${id}" "INVALID"
    fi
  done
}

_looks_like_git_url() {
  local src="$1"
  [[ "${src}" == git@* ]] && return 0
  [[ "${src}" == http://* || "${src}" == https://* || "${src}" == ssh://* ]] && return 0
  [[ "${src}" == *.git ]] && return 0
  return 1
}

pack_install() {
  local src="${1:-}"
  if [[ -z "${src}" ]]; then
    log_error "usage: ./corestack pack install <path-or-git-url>"
    exit 2
  fi
  mkdir -p "${PACKS_DIR}"
  require_cmd python3

  local src_dir tmp_dir pack_id dest
  src_dir=""
  tmp_dir=""
  if _looks_like_git_url "${src}"; then
    require_cmd git
    tmp_dir="$(mktemp -d)"
    git clone --depth 1 "${src}" "${tmp_dir}" >/dev/null
    src_dir="${tmp_dir}"
  else
    if [[ ! -d "${src}" ]]; then
      log_error "pack source is not a directory: ${src}"
      exit 1
    fi
    src_dir="$(cd "${src}" && pwd)"
  fi

  if ! python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" validate "${src_dir}" >/dev/null 2>&1; then
    python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" validate "${src_dir}" || true
    log_error "pack validation failed"
    [[ -n "${tmp_dir}" ]] && rm -rf "${tmp_dir}"
    exit 1
  fi

  pack_id="$(python3 "${REPO_ROOT}/scripts/packs/pack_contract.py" id "${src_dir}")"
  dest="$(pack_dir "${pack_id}")"
  if [[ -e "${dest}" ]]; then
    log_error "pack already installed: ${pack_id}"
    [[ -n "${tmp_dir}" ]] && rm -rf "${tmp_dir}"
    exit 1
  fi

  cp -R "${src_dir}" "${dest}"
  rm -rf "${dest}/.git" >/dev/null 2>&1 || true
  pack_validate_dir "${dest}"
  pack_ensure_env "${dest}"

  log_info "Installed pack: ${pack_id} -> ${dest}"
  [[ -n "${tmp_dir}" ]] && rm -rf "${tmp_dir}"
}

pack_remove() {
  local pack_id="${1:-}"
  if [[ -z "${pack_id}" ]]; then
    log_error "usage: ./corestack pack remove <pack-id>"
    exit 2
  fi
  if ! is_installed_pack "${pack_id}"; then
    log_error "pack is not installed: ${pack_id}"
    exit 1
  fi
  if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
    pack_down "${pack_id}" || true
  else
    log_warn "Docker daemon not reachable; skipping pack stop before removal."
  fi
  rm -rf "$(pack_dir "${pack_id}")"
  log_info "Removed pack: ${pack_id}"
}

pack_up() {
  local pack_id="$1"
  shift || true
  local dir
  dir="$(pack_dir "${pack_id}")"
  pack_validate_dir "${dir}"
  pack_ensure_env "${dir}"
  pack_compose_cmd "${pack_id}" up -d --remove-orphans "$@"
}

pack_down() {
  local pack_id="$1"
  shift || true
  local dir
  dir="$(pack_dir "${pack_id}")"
  pack_validate_dir "${dir}"
  pack_ensure_env "${dir}"
  pack_compose_cmd "${pack_id}" down --remove-orphans "$@"
}

pack_status() {
  local pack_id="$1"
  shift || true
  local dir
  dir="$(pack_dir "${pack_id}")"
  pack_validate_dir "${dir}"
  pack_ensure_env "${dir}"
  pack_compose_cmd "${pack_id}" ps "$@"
}

pack_logs() {
  local pack_id="$1"
  shift || true
  local dir
  dir="$(pack_dir "${pack_id}")"
  pack_validate_dir "${dir}"
  pack_ensure_env "${dir}"
  pack_compose_cmd "${pack_id}" logs --follow --tail 200 "$@"
}

ensure_compose_file() {
  if [[ ! -f "${COMPOSE_FILE}" ]]; then
    log_error "compose file not found: ${COMPOSE_FILE}"
    exit 1
  fi
}

ensure_env_file() {
  if [[ -f "${ENV_FILE}" ]]; then
    return 0
  fi

  if [[ ! -f "${ENV_EXAMPLE_FILE}" ]]; then
    log_error "env file not found (${ENV_FILE}) and template missing (${ENV_EXAMPLE_FILE})"
    exit 1
  fi

  cp "${ENV_EXAMPLE_FILE}" "${ENV_FILE}"
  log_info "Created env file from template: ${ENV_FILE}"
}

compose_cmd() {
  local args=( -p "${PROJECT_NAME}" -f "${COMPOSE_FILE}" )
  if [[ -f "${ENV_FILE}" ]]; then
    args=( --env-file "${ENV_FILE}" "${args[@]}" )
  fi
  docker compose "${args[@]}" "$@"
}

confirm_destroy() {
  echo "WARNING: 'destroy' removes containers, networks, and volumes (deletes persisted data)."
  echo "Type DESTROY to continue:"
  local answer
  read -r answer
  if [[ "${answer}" != "DESTROY" ]]; then
    log_info "Aborted."
    exit 1
  fi
}

wait_for_ollama() {
  local retries="${1:-60}"
  local delay_seconds="${2:-2}"
  local attempt

  for ((attempt=1; attempt<=retries; attempt++)); do
    if curl -fsS "http://localhost:11434/api/tags" >/dev/null 2>&1; then
      log_info "Ollama API is reachable at http://localhost:11434/api/tags"
      return 0
    fi
    sleep "${delay_seconds}"
  done

  log_warn "Ollama API did not become ready in time."
  return 1
}

get_env_value() {
  local key="$1"
  local default_value="$2"
  local value=""

  if [[ -n "${!key:-}" ]]; then
    echo "${!key}"
    return 0
  fi

  if [[ -f "${ENV_FILE}" ]]; then
    value="$(awk -F= -v key="${key}" '
      /^[[:space:]]*#/ { next }
      $1 == key { v=substr($0, index($0, "=") + 1) }
      END { print v }
    ' "${ENV_FILE}")"
  fi

  if [[ -n "${value}" ]]; then
    echo "${value}"
  else
    echo "${default_value}"
  fi
}

pull_ollama_model() {
  local model="$1"
  if [[ -z "${model}" ]]; then
    return 0
  fi
  log_info "Pulling Ollama model: ${model}"
  compose_cmd exec -T ollama ollama pull "${model}"
}

seed_models() {
  ensure_env_file
  require_cmd curl

  compose_cmd up -d ollama
  wait_for_ollama

  local chat_model embedding_model extra_models skip_llama
  chat_model="$(get_env_value CHAT_MODEL "${DEFAULT_CHAT_MODEL}")"
  embedding_model="$(get_env_value EMBEDDING_MODEL "${DEFAULT_EMBEDDING_MODEL}")"
  extra_models="$(get_env_value CORESTACK_DEFAULT_MODELS "")"
  skip_llama="$(get_env_value CORESTACK_SKIP_LLAMA "false")"

  declare -a models=()
  declare -A seen=()
  local model

  for model in "${chat_model}" "${embedding_model}"; do
    if [[ -n "${model}" && -z "${seen[${model}]+x}" ]]; then
      models+=("${model}")
      seen["${model}"]=1
    fi
  done

  if [[ "${skip_llama,,}" != "true" ]]; then
    if [[ -z "${seen[${DEFAULT_SANITY_MODEL}]+x}" ]]; then
      models+=("${DEFAULT_SANITY_MODEL}")
      seen["${DEFAULT_SANITY_MODEL}"]=1
    fi
  fi

  if [[ -n "${extra_models}" ]]; then
    local item trimmed
    IFS=',' read -r -a extra_array <<< "${extra_models}"
    for item in "${extra_array[@]}"; do
      trimmed="$(echo "${item}" | xargs)"
      if [[ -n "${trimmed}" && -z "${seen[${trimmed}]+x}" ]]; then
        models+=("${trimmed}")
        seen["${trimmed}"]=1
      fi
    done
  fi

  for model in "${models[@]}"; do
    pull_ollama_model "${model}"
  done

  compose_cmd restart open-webui

  cat <<EOF
Model seeding complete.
- Open WebUI: http://localhost:3000
- Ollama tags: http://localhost:11434/api/tags
If model list does not refresh immediately, reload Open WebUI.
EOF
}

check_port_conflicts() {
  local expected_name="$1"
  local port="$2"

  local docker_owner
  docker_owner="$(docker ps --format '{{.Names}} {{.Ports}}' | awk -v p=":${port}->" '$0 ~ p {print $1; exit}')"
  if [[ -n "${docker_owner}" ]]; then
    if [[ "${docker_owner}" == "${expected_name}" ]]; then
      log_info "Port ${port}: bound by expected container (${docker_owner})"
    else
      log_warn "Port ${port}: bound by container ${docker_owner} (expected ${expected_name})"
    fi
    return 0
  fi

  if command -v ss >/dev/null 2>&1; then
    if ss -ltnH 2>/dev/null | awk -v p=":${port}" '$4 ~ p"$" { found=1 } END { exit(found ? 0 : 1) }'; then
      log_warn "Port ${port}: in use by a non-Docker process."
      return 0
    fi
  elif command -v lsof >/dev/null 2>&1; then
    if lsof -nP -iTCP:"${port}" -sTCP:LISTEN >/dev/null 2>&1; then
      log_warn "Port ${port}: in use by a non-Docker process."
      return 0
    fi
  fi

  log_info "Port ${port}: free"
}

doctor() {
  require_tools
  ensure_compose_file

  if docker info >/dev/null 2>&1; then
    log_info "Docker daemon reachable."
  else
    log_error "Docker daemon is not reachable."
    exit 1
  fi

  if docker run --rm alpine:3.20 sh -c "nslookup pypi.org >/dev/null 2>&1"; then
    log_info "Container DNS check passed (pypi.org)."
  else
    cat <<'EOF'
WARN: Container DNS check failed.
Fix:
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json >/dev/null <<'JSON'
{
  "dns": ["1.1.1.1", "8.8.8.8"]
}
JSON
sudo systemctl restart docker
EOF
  fi

  check_port_conflicts "${PROJECT_NAME}-ollama-1" 11434
  check_port_conflicts "${PROJECT_NAME}-open-webui-1" 3000
  check_port_conflicts "${PROJECT_NAME}-n8n-1" 5678
  check_port_conflicts "${PROJECT_NAME}-launcher-1" 8080
  check_port_conflicts "${PROJECT_NAME}-adminer-1" 8081
  check_port_conflicts "${PROJECT_NAME}-tool-gateway-1" 8787
  check_port_conflicts "${PROJECT_NAME}-postgres-1" 5432
}

up_stack() {
  ensure_env_file
  require_cmd curl

  local seed_after_up="false"
  local no_seed="false"
  local -a compose_args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-seed)
        no_seed="true"
        ;;
      --seed-models)
        seed_after_up="true"
        ;;
      *)
        compose_args+=("$1")
        ;;
    esac
    shift
  done

  compose_cmd up -d --build --remove-orphans "${compose_args[@]+"${compose_args[@]}"}"
  wait_for_ollama || true

  if [[ "${seed_after_up}" == "false" && "${no_seed}" == "false" ]]; then
    if curl -fsS http://localhost:11434/api/tags | grep -q '"models":\[\]'; then
      seed_after_up="true"
    fi
  fi

  if [[ "${seed_after_up}" == "true" ]]; then
    seed_models
  fi
}

reset_stack() {
  local nuke_volumes="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --nuke-volumes)
        nuke_volumes="true"
        ;;
      *)
        log_error "Unknown reset option: $1"
        exit 1
        ;;
    esac
    shift
  done

  local down_args=( -f "${COMPOSE_FILE}" --project-name "${PROJECT_NAME}" )
  if [[ -f "${ENV_FILE}" ]]; then
    down_args=( --env-file "${ENV_FILE}" "${down_args[@]}" )
  fi

  if [[ "${nuke_volumes}" == "true" ]]; then
    docker compose "${down_args[@]}" down --remove-orphans -v || true
  else
    docker compose "${down_args[@]}" down --remove-orphans || true
  fi

  docker rm -f \
    corestack-ollama \
    corestack-open-webui \
    corestack-n8n \
    corestack-postgres \
    corestack-adminer \
    corestack-tool-gateway \
    corestack-launcher >/dev/null 2>&1 || true

  mapfile -t leftover_containers < <(docker ps -aq --filter "label=com.docker.compose.project=${PROJECT_NAME}")
  if [[ ${#leftover_containers[@]} -gt 0 ]]; then
    docker rm -f "${leftover_containers[@]}" >/dev/null 2>&1 || true
    log_info "Removed ${#leftover_containers[@]} leftover project containers."
  fi

  if [[ "${nuke_volumes}" == "true" ]]; then
    mapfile -t leftover_volumes < <(docker volume ls -q --filter "label=com.docker.compose.project=${PROJECT_NAME}")
    if [[ ${#leftover_volumes[@]} -gt 0 ]]; then
      docker volume rm "${leftover_volumes[@]}" >/dev/null 2>&1 || true
      log_info "Removed ${#leftover_volumes[@]} project volumes."
    fi
  fi
}

main() {
  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    up)
      if [[ $# -gt 0 && "${1}" != -* ]] && is_installed_pack "${1}"; then
        require_tools
        local pack_id="$1"
        shift
        pack_up "${pack_id}" "$@"
      else
      require_tools
      ensure_compose_file
      up_stack "$@"
      fi
      ;;
    seed-models)
      require_tools
      ensure_compose_file
      seed_models
      ;;
    doctor)
      doctor
      ;;
    reset)
      require_tools
      ensure_compose_file
      reset_stack "$@"
      ;;
    down)
      if [[ $# -gt 0 && "${1}" != -* ]] && is_installed_pack "${1}"; then
        require_tools
        local pack_id="$1"
        shift
        pack_down "${pack_id}" "$@"
      else
      require_tools
      ensure_compose_file
      compose_cmd down --remove-orphans "$@"
      fi
      ;;
    start)
      require_tools
      ensure_compose_file
      compose_cmd start "$@"
      ;;
    stop)
      require_tools
      ensure_compose_file
      compose_cmd stop "$@"
      ;;
    restart)
      require_tools
      ensure_compose_file
      compose_cmd down
      compose_cmd up -d
      ;;
    status)
      if [[ $# -gt 0 && "${1}" != -* ]] && is_installed_pack "${1}"; then
        require_tools
        local pack_id="$1"
        shift
        pack_status "${pack_id}" "$@"
      else
      require_tools
      ensure_compose_file
      compose_cmd ps "$@"
      fi
      ;;
    logs)
      if [[ $# -gt 0 && "${1}" != -* ]] && is_installed_pack "${1}"; then
        require_tools
        local pack_id="$1"
        shift
        pack_logs "${pack_id}" "$@"
      else
        require_tools
        ensure_compose_file
        compose_cmd logs --follow --tail 200 "$@"
      fi
      ;;
    destroy)
      require_tools
      ensure_compose_file
      confirm_destroy
      compose_cmd down -v "$@"
      ;;
    pack)
      local sub="${1:-}"
      shift || true
      case "${sub}" in
        list)
          pack_list "$@"
          ;;
        install)
          pack_install "$@"
          ;;
        remove)
          # Best-effort: stop running pack if Docker is available, then remove files.
          if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
            require_tools
          fi
          pack_remove "$@"
          ;;
        *)
          log_error "Unknown pack command: ${sub}"
          usage
          exit 1
          ;;
      esac
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      echo "Unknown command: ${cmd}" >&2
      usage
      exit 1
      ;;
  esac
}

main "$@"
